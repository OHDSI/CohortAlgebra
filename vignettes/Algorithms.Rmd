---
title: "Algorithms for Operations on Cohorts"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Algorithms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides an intuition and informal proof of the correctness of algorithms used in CohortAlgebra.

We will examine three binary operations: union, intersection, and minus using all cases described in [Allen's Interval Algebra](https://www.ics.uci.edu/~alspaugh/cls/shr/allen.html).

## Intersection

```{r setup}
# dataframe with all possible relationships between time intervals
intervals <- tibble::tribble(
  ~relationship,  ~cohort_definition_id, ~subject_id, ~cohort_start_date, ~cohort_end_date,
  "reference",    1,                     1,           "2022-01-05",       "2022-01-10",
  "precedes",     2,                     1,           "2022-01-01",       "2022-01-03",
  "meets",        3,                     1,           "2022-01-01",       "2022-01-04",
  "overlaps",     5,                     1,           "2022-01-01",       "2022-01-05",
  "finished_by",  7,                     1,           "2022-01-01",       "2022-01-10",
  "contains",     8,                     1,           "2022-01-01",       "2022-01-15",
  "starts",       9,                     1,           "2022-01-05",       "2022-01-07",
  "equals",      10,                     1,           "2022-01-05",       "2022-01-10") %>% 
   mutate(across(matches("date"), as.Date))

```


Overlapping intervals
```{r}
(cohort <- intervals %>% 
  filter(relationship %in% c("overalaps", "reference")))

```


Stack all start and end dates in a "long format" table and add a row number ordered by date.
```{r}

# helper function to convert dates back to date type
restoreDates <- function(df) mutate(df, across(matches("date$"), ~as.Date(., origin = "1970-01-01")))
                                               
                                               
(cohort_dates <- sqldf("
  SELECT 
    subject_id,
    cohort_date,
    ROW_NUMBER() OVER(PARTITION BY subject_id ORDER BY cohort_date ASC) cohort_date_seq
  FROM (
    SELECT subject_id,
      cohort_start_date cohort_date
    FROM cohort
     
    UNION ALL -- we need all dates, even if duplicates
     
    SELECT subject_id,
      cohort_end_date cohort_date
    FROM cohort
    ) all_dates") %>% restoreDates())
```

Create every possible interval.
```{r}
(candidate_periods <- sqldf("
  SELECT
    subject_id,
    cohort_date AS candidate_start_date,
    cohort_date_seq,
    LEAD(cohort_date, 1) OVER (
      PARTITION BY subject_id ORDER BY cohort_date, cohort_date_seq ASC) candidate_end_date
  FROM cohort_dates")  %>% restoreDates())
```

Find candidate intervals that fall within cohorts.
```{r}
(candidate_cohort_date <- sqldf("
  SELECT DISTINCT cohort.*,
    candidate_start_date,
    candidate_end_date
  FROM cohort
  INNER JOIN candidate_periods candidate ON cohort.subject_id = candidate.subject_id
    AND candidate_start_date >= cohort_start_date
    AND candidate_end_date <= cohort_end_date")  %>% restoreDates())
```


```{r}
sqldf(glue::glue("
  SELECT 
    subject_id,
    candidate_start_date cohort_start_date,
    candidate_end_date cohort_end_date,
    count(*) as n,
    {nrow(cohort)} as n_to_match
  FROM candidate_cohort_date
  GROUP BY subject_id,
  	candidate_start_date,
  	candidate_end_date
  HAVING COUNT(*) = {nrow(cohort)}")) %>% restoreDates()
```


## Union

## Minus